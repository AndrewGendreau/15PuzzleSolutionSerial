/*NAME: functions-2.cASSIGNMENT: Project A -15 Puzzle, serial versionDATE: Oct 14th 2016VERSION: 2.0FILENAME: functions-2.cPURPOSE: This module will contain functions to check if a given instance of the 	15 puzzle is solvable or not. It will use a methodology adapted from this source:	https://www.cs.bham.ac.uk/~mdr/teaching/modules04/java2/TilesSolvability.html	Applying this methodology, the module will first count the number of inversions in the	given array. Then it will locate the blank's position counting up from the bottom row.	Knowing we have an even grid width, the given puzzle is only solvable if the following is true:		-The blank is on an even row counting from the bottom and the number of inversions is odd		-The blank is on an odd row counting from the bottom and the number of inversions is even.AUTHOR: Andrew Gendreau*/#include <stdio.h>#ifndef HASH_H_#define HASH_H_#include "hashList.h"#endif#ifndef ARRAYREADER_H_#define ARRAYREADER_H_#include "arrayReader.h"#endif#ifndef FUNCTIONS_H_#define FUNCTIONS_H_#include "functions-2.h"#endif/***Name: inversion*Purpose: This function will count the number of inversions in the given array	An inversion is a pair of numbers i and j, such that i appears in the array	before j but is bigger than j. However, since 0 is the blank marker, once we find	a pair of numbers that looks like an inversion, we have to check neither are 0 or that	will throw off the result.*Parameters: 	arr[] --1D form of the 15 puzzle*Returns:	number of inversions*Author: Andrew Gendreau**/int inversion(int arr[]){	int counter;					//counter for the number of inversions	int i;						//current row	int j;						//current column	counter = 0;	for (i = 0; i < BOARDSIZE; i++)	{		for (j = i + 1; j < BOARDSIZE; j++)		{			if(arr[i] > arr[j] && i < j)			{				if(arr[i] > 0 && arr[j] > 0)				{					counter++;				}			}		}	}	return counter;}/***Name: rowPosition*Purpose: This function will locate the position of the blank counting 	from the bottom. It will do this by running through the array from 	BOARDHEIGHT-1 (or 3) and then running through the row until it finds	0, at which point we return, we've found the blank. It will return -1 should	it be unable to locate the blank.*Parameters: 	puzzle[BOARDHEIGHT][BOARDWIDTH] --15 puzzle*Returns:	location of the blank or -1*Author: Andrew Gendreau**/int rowPosition(int puzzle[BOARDHEIGHT][BOARDWIDTH]){	int i;								//i is the current row we're in	int j;								//j is the current column	int counter;							//counter for blank location, this one starts at 1	counter = 1;	i = BOARDHEIGHT-1;	while(i >= 0)	{		for(j = 0; j < BOARDWIDTH; j++)		{			if(puzzle[i][j] == 0)			{				return counter;			}		}		i--;		counter++;	}	return -1;}/***Name: solvable*Purpose: This function will check a given 2D instance of the 15	puzzle problem for solvability. It will use the above methods to do so.	As mentioned above, we know it is solvable in the following two cases:		-The blank is on an even row counting from the bottom and the number of inversions is odd		-The blank is on an odd row counting from the bottom and the number of inversions is even.	Otherwise, we know it is not solvable.*Parameters: 	puzzle[BOARDHEIGHT][BOARDWIDTH] --15 puzzle*Returns:	1 if the puzzle is solvable	0 if it is not*Author: Andrew Gendreau**/int solvable(int blankSpot, int puzzle1D[BOARDSIZE]) {	int count_inversion;						//inversion count	int isSolvable;							//integer to hold the return of this function		isSolvable = -1;	count_inversion = inversion(puzzle1D);		if(blankSpot % 2 == 0)						//if the blank is on an even row	{		if(count_inversion % 2 != 0)		{			isSolvable = 1;		}		else		{			isSolvable = 0;		}	}	else								//the blank is on an odd row	{		if(count_inversion % 2 == 0)		{			isSolvable =  1;		}		else		{			isSolvable =  0;		}	}	return isSolvable;}